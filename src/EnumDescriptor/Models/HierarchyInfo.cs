using EnumDescriptor.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using Microsoft.CodeAnalysis.CSharp;

namespace EnumDescriptor.Models
{
    /// <summary>
    /// Builds hierarchy information for the type provided
    /// This will contain namespace information and possible parents for nested types
    /// </summary>
    /// <param name="FilenameHint"></param>
    /// <param name="MetadataName"></param>
    /// <param name="Namespace"></param>
    /// <param name="Hierarchy"></param>
    internal sealed record HierarchyInfo(string FilenameHint, string MetadataName, string Namespace, EnumDescriptor.Models.TypeInfo[] Hierarchy)
    {
        public static HierarchyInfo From(INamedTypeSymbol typeSymbol)
        {
            var hierarchy = new List<EnumDescriptor.Models.TypeInfo>();

            for (INamedTypeSymbol? parent = typeSymbol; parent is not null; parent = parent.ContainingType)
            {
                hierarchy.Add(new TypeInfo(parent.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                parent.TypeKind,
                parent.IsRecord));
            }

            return new(typeSymbol.GetFullyQualifiedMetadataName(),
                typeSymbol.MetadataName,
                typeSymbol.ContainingNamespace.ToDisplayString(new(typeQualificationStyle: NameAndContainingTypesAndNamespaces)),
                hierarchy.ToArray());
        }

        public CompilationUnitSyntax GetCompilationUnit(MemberDeclarationSyntax memberDeclaration, BaseListSyntax? baseList = null)
        {
            TypeDeclarationSyntax typeDeclarationSyntax =
                ClassDeclaration($"{Hierarchy[0].QualifiedName}Extensions")
                .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword))
                .AddMembers(memberDeclaration);

            if (baseList is not null)
            {
                typeDeclarationSyntax = typeDeclarationSyntax.WithBaseList(baseList);
            }

            // A trivia list is used to populate the header of a source compilation. This is where
            // we tell any style plugins and other generators to ignore this file, 
            // using the "// <auto-generated/>" tag
            // We also tell it to ignore warnings and nullable, as we don't want to potentially send errors to 
            // a developer that they cannot fix
            var syntaxTriviaList = TriviaList(
                Comment("// <auto-generated/>"),
                Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)));


            // return the original type declaration with the added trivia
            if (string.IsNullOrEmpty(Namespace))
            {
                return
                    CompilationUnit()
                    .AddMembers(typeDeclarationSyntax.WithLeadingTrivia(syntaxTriviaList))
                    .NormalizeWhitespace();
            }

            return
            CompilationUnit().AddMembers(
            NamespaceDeclaration(IdentifierName(Namespace))
            .WithLeadingTrivia(syntaxTriviaList)
            .AddMembers(typeDeclarationSyntax))
            .NormalizeWhitespace();
        }
    }
}